-- ===============================
-- LOAD WINDUI
-- ===============================
local WindUI = loadstring(game:HttpGet(
    "https://github.com/Footagesus/WindUI/releases/latest/download/main.lua"
))()

local Players = game:GetService("Players")
local LP = Players.LocalPlayer

-- ===============================
-- COLORS
-- ===============================
local NEON_BLUE   = Color3.fromHex("#00E5FF")
local NEON_YELLOW = Color3.fromHex("#FFF700")
local DARK_BG1    = Color3.fromHex("#0B1220")
local DARK_BG2    = Color3.fromHex("#020409")
local WHITE       = Color3.fromHex("#FFFFFF")

-- ===============================
-- GRADIENTS
-- ===============================
local NEON_GRADIENT = WindUI:Gradient({
    ["0"]   = { Color = NEON_BLUE,   Transparency = 0 },
    ["100"] = { Color = NEON_YELLOW, Transparency = 0 },
}, { Rotation = 45 })

local BACKGROUND_GRADIENT = WindUI:Gradient({
    ["0"]   = { Color = NEON_BLUE,   Transparency = 0.2 },
    ["100"] = { Color = NEON_YELLOW, Transparency = 0.2 },
}, { Rotation = 45 })

local DARK_TAB_GRADIENT = WindUI:Gradient({
    ["0"]   = { Color = DARK_BG1, Transparency = 0 },
    ["100"] = { Color = DARK_BG2, Transparency = 0 },
}, { Rotation = 90 })

-- ===============================
-- THEME
-- ===============================
WindUI:AddTheme({
    Name = "Senixa Theme",

    Accent = NEON_GRADIENT,
    Background = BACKGROUND_GRADIENT,
    BackgroundTransparency = 0.3,

    Outline = NEON_YELLOW,
    Text = WHITE,
    Placeholder = Color3.fromHex("#B6F7FF"),
    Icon = WHITE,
    Hover = NEON_GRADIENT,

    WindowBackground = BACKGROUND_GRADIENT,
    WindowShadow = Color3.fromHex("#000000"),

    WindowTopbarButtonIcon = WHITE,
    WindowTopbarTitle = WHITE,
    WindowTopbarAuthor = WHITE,
    WindowTopbarIcon = WHITE,

    TabBackground = DARK_TAB_GRADIENT,
    TabTitle = WHITE,
    TabIcon = WHITE,

    ElementBackground = DARK_TAB_GRADIENT,
    ElementTitle = WHITE,
    ElementDesc = Color3.fromHex("#C9F6FF"),
    ElementIcon = Color3.fromHex("#C9F6FF"),

    Button = NEON_GRADIENT,
    Toggle = NEON_GRADIENT,
    ToggleBar = WHITE,
    Checkbox = NEON_GRADIENT,
    CheckboxIcon = WHITE,
    Slider = NEON_GRADIENT,
    SliderThumb = WHITE,
})

WindUI:SetTheme("NeonDarkReadable")

local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local ProximityPromptService = game:GetService("ProximityPromptService")
local lp = Players.LocalPlayer
local CoreGui = game:GetService("CoreGui")
local UserInputService = game:GetService("UserInputService")
local VirtualUser = game:GetService("VirtualUser")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local CollectionService = game:GetService("CollectionService")


local Window = WindUI:CreateWindow({
    Title = "Rick HUB",
    Icon = "rbxassetid://108958018844079",
    Theme = "Senixa Theme",
    Transparent = true,
    Resizable = true,
    Size = UDim2.fromOffset(850, 400), 
    MinSize = Vector2.new(480, 480),   
    MaxSize = Vector2.new(1000, 500),   
    SideBarWidth = 180,               

    User = {
        Enabled = true,
        Anonymous = false,
        Name = LP.Name,
        Image = "rbxthumb://type=AvatarHeadShot&id=" .. LP.UserId .. "&w=420&h=420",
    },
})


Window:EditOpenButton({ Enabled = false })

local ScreenGui = Instance.new("ScreenGui")
local ToggleBtn = Instance.new("ImageButton")

ScreenGui.Name = "WindUI_Toggle"
ScreenGui.ResetOnSpawn = false
ScreenGui.Parent = CoreGui

ToggleBtn.Size = UDim2.new(0, 50, 0, 50)
ToggleBtn.Position = UDim2.new(0, 20, 0.5, -25)
ToggleBtn.BackgroundTransparency = 1
ToggleBtn.Image = "rbxassetid://108958018844079"
ToggleBtn.Active = true
ToggleBtn.Draggable = true
ToggleBtn.Parent = ScreenGui

local opened = true

local function toggle()
    opened = not opened
    if Window.UI then
        Window.UI.Enabled = opened
    else
        Window:Toggle()
    end
end

ToggleBtn.MouseButton1Click:Connect(function()
    ToggleBtn:TweenSize(
        UDim2.new(0, 56, 0, 56),
        Enum.EasingDirection.Out,
        Enum.EasingStyle.Quad,
        0.12,
        true,
        function()
            ToggleBtn:TweenSize(
                UDim2.new(0, 50, 0, 50),
                Enum.EasingDirection.Out,
                Enum.EasingStyle.Quad,
                0.12,
                true
            )
        end
    )
    toggle()
end)

UserInputService.InputBegan:Connect(function(input, gp)
    if gp then return end
    if input.KeyCode == Enum.KeyCode.T then
        toggle()
    end
end)


-- ================= CONFIG =================
local CHECK_DISTANCE = 300
local SPEED = 200
local HEIGHT_RESET = 6
local WAVE_SAFE_DIST = 80

local Enabled = false
local tweening = false
local arrived = false
local currentGapPart
local AutoCollectEnabled = false


-- ====== STATECombat ======
local HitLongEnabled = false
local ShowRangeEnabled = false
local HitRangeValue = 50
local ORIGINAL_SIZES = {}
local Connections = {}
local char, hrp



-- ====
-- Dodge Wave
-- ===========

local GapsRoot = workspace:WaitForChild("Misc"):WaitForChild("Gaps")


local function setupCharacter(character)
	char = character
	hrp = char:WaitForChild("HumanoidRootPart")

	tweening = false
	arrived = false
	currentGapPart = nil
end

if lp.Character then
	setupCharacter(lp.Character)
end

lp.CharacterAdded:Connect(setupCharacter)

-- noclip
local function setNoclip(state)
	if not char then return end
	for _,v in ipairs(char:GetDescendants()) do
		if v:IsA("BasePart") then
			v.CanCollide = not state
		end
	end
end


local function isWave(obj)
	return obj.Name:match("^Wave%d+_Visual$")
		or obj.Name == "WackyWave_Visual"
end

local function getNearestWave()
	if not hrp then return nil, nil end

	local nearest, dist = nil, math.huge

	for _,v in ipairs(workspace:GetChildren()) do
		if isWave(v) then
			local pos =
				v:IsA("BasePart") and v.Position
				or (v.PrimaryPart and v.PrimaryPart.Position)

			if pos then
				local d = (hrp.Position - pos).Magnitude
				if d < dist then
					dist = d
					nearest = pos
				end
			end
		end
	end

	return nearest, dist
end

local function waveBlockingGap(wavePos, gapPos)
	local toGap = gapPos - hrp.Position
	local toWave = wavePos - hrp.Position
	if toGap.Magnitude == 0 or toWave.Magnitude == 0 then return false end
	if toGap.Unit:Dot(toWave.Unit) < 0.6 then return false end
	return toWave.Magnitude < toGap.Magnitude and toWave.Magnitude < WAVE_SAFE_DIST
end


local function getBestGap()
	if not hrp then return nil end

	local best, bestDist = nil, math.huge
	local wavePos, waveDist = getNearestWave()

	for _,gap in ipairs(GapsRoot:GetChildren()) do
		local targetPart
		if gap.Name == "Gap6" then
			targetPart = gap:FindFirstChild("Mud")
		else
			local part = gap:GetChildren()[2]
			targetPart = part and (part:IsA("BasePart") and part or part.PrimaryPart)
		end

		if targetPart then
			local dist = (hrp.Position - targetPart.Position).Magnitude
			local blocked = false

			if wavePos and waveDist <= CHECK_DISTANCE then
				blocked = waveBlockingGap(wavePos, targetPart.Position)
			end

			if not blocked and dist < bestDist then
				bestDist = dist
				best = targetPart
			end
		end
	end

	return best
end

-- tween function
local function tweenToGap()
	if tweening or arrived or not hrp then return end
	tweening = true

	local gap = getBestGap()
	if not gap then tweening = false return end
	currentGapPart = gap

	setNoclip(true)

	local downPos = hrp.Position - Vector3.new(0,3,0)
	local downTween = TweenService:Create(
		hrp,
		TweenInfo.new(3 / SPEED, Enum.EasingStyle.Linear),
		{CFrame = CFrame.new(downPos)}
	)
	downTween:Play()

	downTween.Completed:Once(function()
		if not hrp then return end

		local target = gap.Position + Vector3.new(0,3,0)
		local time = (hrp.Position - target).Magnitude / SPEED

		local goTween = TweenService:Create(
			hrp,
			TweenInfo.new(time, Enum.EasingStyle.Linear),
			{CFrame = CFrame.new(target)}
		)
		goTween:Play()

		goTween.Completed:Once(function()
			setNoclip(false)
			tweening = false
			arrived = true
		end)
	end)
end

RunService.Heartbeat:Connect(function()
	if not Enabled or not hrp then return end

	if arrived and currentGapPart then
		if math.abs(hrp.Position.Y - currentGapPart.Position.Y) > HEIGHT_RESET then
			arrived = false
			currentGapPart = nil
		end
	end
	if arrived then return end

	local _, waveDist = getNearestWave()
	if waveDist and waveDist <= CHECK_DISTANCE then
		tweenToGap()
	end
end)

-- ===============================

-- Auto pickup 

-- -----------

local AutoPromptEnabled = false
local lastFire = {}

for _, v in ipairs(workspace:GetDescendants()) do
	if v:IsA("ProximityPrompt") then
		v.HoldDuration = 0
		v.RequiresLineOfSight = false
	end
end

ProximityPromptService.PromptShown:Connect(function(prompt)
	if not AutoPromptEnabled then return end

	local char = lp.Character
	local hrp = char and char:FindFirstChild("HumanoidRootPart")
	if not hrp then return end

	local part = prompt.Parent
	if not part or not part:IsA("BasePart") then return end

	if lastFire[prompt] and tick() - lastFire[prompt] < 0.05 then
		return
	end

	local dist = (part.Position - hrp.Position).Magnitude
	if dist <= prompt.MaxActivationDistance then
		lastFire[prompt] = tick()
		pcall(function()
			fireproximityprompt(prompt)
		end)
	end
end)





-- ======
-- Godmode
-- =====
-- ================= SERVICES =================
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local lp = Players.LocalPlayer
local FAKE_HP = 100000

-- ================= STATE =================
local AntiWaveEnabled = false
local Connections = {}

local function ClearConnections()
    for _, c in ipairs(Connections) do
        pcall(function()
            c:Disconnect()
        end)
    end
    table.clear(Connections)
end

-- ================= MAIN =================
local function AntiWaveInfinite(char)
    local hum = char:WaitForChild("Humanoid")

    hum.BreakJointsOnDeath = false
    hum.MaxHealth = math.huge
    hum.Health = FAKE_HP

    hum.WalkSpeed = 16
    hum.JumpPower = 50
    hum.UseJumpPower = true

    -- ‡∏Å‡∏±‡∏ô‡∏ï‡∏≤‡∏¢‡∏à‡∏≤‡∏Å‡πÄ‡∏ß‡∏ü
    table.insert(Connections,
        hum:GetPropertyChangedSignal("Health"):Connect(function()
            if not AntiWaveEnabled then return end
            if hum.Health <= 0 then
                hum.Health = FAKE_HP
                hum:ChangeState(Enum.HumanoidStateType.GettingUp)
            end
        end)
    )

    table.insert(Connections,
        hum.StateChanged:Connect(function(_, new)
            if not AntiWaveEnabled then return end
            if new == Enum.HumanoidStateType.Dead then
                hum.Health = FAKE_HP
                hum:ChangeState(Enum.HumanoidStateType.GettingUp)
            end
        end)
    )

    table.insert(Connections,
        RunService.Heartbeat:Connect(function()
            if not AntiWaveEnabled then return end
            if hum.Health <= 0 then
                hum.Health = FAKE_HP
            end
        end)
    )
end







-- --------
-- CombatTab
-- ----------

local lp = Players.LocalPlayer
local bp = lp:WaitForChild("Backpack")

-- ====== VISUAL ======
local function createBoxVisual(parent, size)
    local box = Instance.new("Part")
    box.Name = "BoxVisual"
    box.Size = size
    box.Transparency = 0.8
    box.Color = Color3.fromRGB(255, 100, 100)
    box.Material = Enum.Material.Neon
    box.CanCollide = false
    box.Anchored = false
    box.CastShadow = false

    local wireframe = Instance.new("SelectionBox")
    wireframe.Adornee = box
    wireframe.Color3 = Color3.fromRGB(255, 50, 50)
    wireframe.LineThickness = 0.05
    wireframe.Parent = box

    box.Parent = parent
    return box
end

-- ====== APPLY HITBOX ======
local function applyHitbox(tool)
    local hitbox = tool:FindFirstChild("Hitbox")
    if not hitbox then return end

    if not ORIGINAL_SIZES[hitbox] then
        ORIGINAL_SIZES[hitbox] = hitbox.Size
    end

    if HitLongEnabled then
        hitbox.Size = Vector3.new(HitRangeValue, HitRangeValue, HitRangeValue)
        tool.ToolTip = ("üì¶ Hit Range\nSize: %d√ó%d√ó%d")
            :format(HitRangeValue, HitRangeValue, HitRangeValue)
    else
        hitbox.Size = ORIGINAL_SIZES[hitbox]
    end
end

-- ====== APPLY VISUAL ======
local function applyVisual(tool)
    local hitbox = tool:FindFirstChild("Hitbox")
    if not hitbox then return end

    if Connections[tool] then
        Connections[tool]:Disconnect()
        Connections[tool] = nil
    end

    local old = tool:FindFirstChild("BoxVisual")
    if old then old:Destroy() end

    if not ShowRangeEnabled then return end

    local box = createBoxVisual(
        tool,
        Vector3.new(HitRangeValue, HitRangeValue, HitRangeValue)
    )

    Connections[tool] = RunService.Heartbeat:Connect(function()
        if box.Parent and hitbox.Parent then
            box.CFrame = hitbox.CFrame
        end
    end)
end

-- ====== TOOL SETUP ======
local function setupTool(tool)
    if not tool:IsA("Tool") then return end
    if not tool:FindFirstChild("Hitbox") then return end

    tool.Equipped:Connect(function()
        applyHitbox(tool)
        applyVisual(tool)
    end)

    tool.Unequipped:Connect(function()
        local box = tool:FindFirstChild("BoxVisual")
        if box then box:Destroy() end

        if Connections[tool] then
            Connections[tool]:Disconnect()
            Connections[tool] = nil
        end
    end)
end

-- ====== INIT ======
for _, tool in ipairs(bp:GetChildren()) do
    setupTool(tool)
end
bp.ChildAdded:Connect(setupTool)




local MainTab = Window:Tab({Title = "Main", Icon = "user"})




MainTab:Toggle({
    Title = "walk Speed",
    Desc = "‡∏ß‡∏¥‡πà‡∏á‡πÄ‡∏£‡πá‡∏ß",
    Default = false,
    Callback = function(state)
        getgenv().SPEED_ON = state
        if state then
            localPlayer:SetAttribute("CurrentSpeed", getgenv().SPEED_VALUE)
        end
    end
})


MainTab:Slider({
    Title = "Speed Value",
    Desc = "‡∏õ‡∏£‡∏±‡∏ö‡∏™‡∏õ‡∏µ‡∏î",
    Step = 1,
    Value = {
        Min = 0,
        Max = 3000,
        Default = 500,
    },
    Callback = function(value)
        getgenv().SPEED_VALUE = value
        if getgenv().SPEED_ON then
            localPlayer:SetAttribute("CurrentSpeed", value)
        end
    end
})


local player = Players.LocalPlayer
local camera = workspace.CurrentCamera
local zoomConnection

MainTab:Button({
    Title = "Unlock Camera Zoom",
    Desc = "‡∏ó‡∏≥‡πÉ‡∏´‡πâ‡∏ã‡∏π‡∏°‡πÑ‡∏Å‡∏•",
    Callback = function()
        if zoomConnection then
            zoomConnection:Disconnect()
            zoomConnection = nil
        end

        zoomConnection = RunService.RenderStepped:Connect(function()
            player.CameraMode = Enum.CameraMode.Classic
            camera.CameraType = Enum.CameraType.Custom
            player.CameraMinZoomDistance = 0.5
            player.CameraMaxZoomDistance = 1000
        end)

        WindUi:Notify({
            Title = "unlockCamera Zoom‚úÖ",
            Content = "‡∏õ‡∏•‡∏î‡∏•‡πá‡∏≠‡∏Å‡∏ã‡∏π‡∏°‚úÖ",
            Duration = 3
        })
    end
})

local lp = Players.LocalPlayer




MainTab:Toggle({
    Title = "Auto pick Brainrots",
    Desc = "‡∏´‡∏¢‡∏¥‡∏ö‡πÄ‡∏ö‡∏£‡∏≠‡∏™‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥",
    Default = false,
    Callback = function(state)
        AutoPromptEnabled = state
    end
})



local Net = require(ReplicatedStorage.Packages.Net)
local ClientGlobals = require(ReplicatedStorage.Client.Modules.ClientGlobals)
local PlotAction = Net:RemoteFunction("Plot.PlotAction")
task.spawn(function()
	while true do
		if AutoCollectEnabled then
			for _, plot in ipairs(CollectionService:GetTagged("Plot")) do
				local uuid = plot.Name

				-- ‡πÄ‡∏ä‡πá‡∏Ñ‡∏ß‡πà‡∏≤ Plot ‡πÄ‡∏õ‡πá‡∏ô‡∏Ç‡∏≠‡∏á‡πÄ‡∏£‡∏≤
				if ClientGlobals.Plots:TryIndex({ uuid, "player" }) == Players.LocalPlayer then
					local maxSlots = ClientGlobals.Plots:TryIndex({ uuid, "data", "MaxSlots" }) or 10

					for slot = 1, maxSlots do
						if not AutoCollectEnabled then break end

						local args = {
							"Collect Money",
							uuid,
							tostring(slot)
						}

						pcall(function()
							PlotAction:InvokeServer(unpack(args))
						end)

						task.wait(0.05)
					end
				end
			end
		end
		task.wait(0.5)
	end
end)



MainTab:Toggle({
    Title = "Auto Collect Money",
    Desc = "‡πÄ‡∏Å‡πá‡∏ö‡πÄ‡∏á‡∏¥‡∏ô‡∏ó‡∏µ‡πà‡∏ê‡∏≤‡∏ô‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥",
    Default = false,
    Callback = function(state)
        AutoCollectEnabled = state
    end
})


-- ===== Services =====
local Players = game:GetService("Players")
local CollectionService = game:GetService("CollectionService")
local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local ClientGlobals = require(ReplicatedStorage.Client.Modules.ClientGlobals)
local Net = require(ReplicatedStorage.Packages.Net)
local PlotAction = Net:RemoteFunction("Plot.PlotAction")

local lp = Players.LocalPlayer

-- ===== STATE =====
local AutoUpgrade = false
local SelectedBrainrot = nil

-- ===== FIND OUR BASE + UUID =====
local function getMyBaseAndUUID()
	for _, plot in ipairs(CollectionService:GetTagged("Plot")) do
		local uuid = plot.Name
		if ClientGlobals.Plots:TryIndex({ uuid, "player" }) == lp then
			return uuid, Workspace.Bases:FindFirstChild(uuid)
		end
	end
end

-- ===== GET BRAINROT VALUES (NO ROOT) =====
local function getBrainrotValues()
	local _, base = getMyBaseAndUUID()
	if not base then return { "No Base" } end

	local values = {}

	for slot = 1, 30 do
		local slotFolder = base:FindFirstChild("slot "..slot.." brainrot")
		if slotFolder then
			for _, obj in ipairs(slotFolder:GetChildren()) do
				-- ‚ùå ‡∏ï‡∏±‡∏î Root ‡∏≠‡∏≠‡∏Å
				if obj.Name ~= "Root" then
					table.insert(values, "Slot "..slot.." : "..obj.Name)
				end
			end
		end
	end

	return (#values > 0) and values or { "No Brainrot" }
end

-- ===== DROPDOWN (WindUI API ‡∏ï‡∏≤‡∏°‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏Ñ‡∏∏‡∏ì) =====
local BrainrotDropdown = MainTab:Dropdown({
	Title = "Select Brainrot",
	Values = getBrainrotValues(),
	Callback = function(selected)
		SelectedBrainrot = selected
		print("Selected:", selected)
	end
})

-- ===== TOGGLE AUTO UPGRADE =====
MainTab:Toggle({
	Title = "Auto Upgrade",
	Callback = function(state)
		AutoUpgrade = state
		print("Auto Upgrade:", state)
	end
})

-- ===== REAL-TIME DROPDOWN UPDATE =====
local lastHash = ""

RunService.Heartbeat:Connect(function()
	local values = getBrainrotValues()
	local hash = table.concat(values, "|")

	if hash ~= lastHash then
		lastHash = hash
		BrainrotDropdown:Refresh(values)
	end
end)

-- ===== AUTO UPGRADE LOOP =====
task.spawn(function()
	while task.wait(2) do
		if not AutoUpgrade then continue end
		if not SelectedBrainrot then continue end

		-- ‡πÅ‡∏¢‡∏Å slot ‡∏à‡∏≤‡∏Å‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏° Dropdown
		local slot = SelectedBrainrot:match("Slot%s+(%d+)")
		if not slot then continue end

		local uuid = getMyBaseAndUUID()
		if not uuid then continue end

		pcall(function()
			PlotAction:InvokeServer(
				"Upgrade Brainrot",
				uuid,
				tostring(slot)
			)
		end)
	end
end)



local localPlayer = Players.LocalPlayer
getgenv().SPEED_VALUE = 500
getgenv().SPEED_ON = false

task.spawn(function()
    while true do
        if getgenv().SPEED_ON then
            localPlayer:SetAttribute("CurrentSpeed", getgenv().SPEED_VALUE)
        end
        task.wait(0.1)
    end
end)





local WaveTab = Window:Tab({Title = "Wave", Icon = "user"})


-- ================== SERVICES ==================
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local lp = Players.LocalPlayer
local SellRemote =
    ReplicatedStorage
        :WaitForChild("RemoteFunctions")
        :WaitForChild("SellTool")

-- ================== CONFIG ==================
local delay_sell = 0.03

-- ================== DATA ==================
local Checked = {}
local ClassData = {}
local queue = {}

local scanning = false
local selling = false
local backpackConn

local sellToggleOn = false
local selectedClasses = {}

-- ================== UTILS ==================
local function getCharacter()
    return lp.Character or lp.CharacterAdded:Wait()
end

local function hasToolTipText(tool)
    local ok, tip = pcall(function()
        return tool.ToolTip
    end)
    return ok and type(tip) == "string" and tip ~= ""
end

local function shouldSkip(tool)
    if hasToolTipText(tool) then return true end
    if tool:FindFirstChild("Hitbox") then return true end
    return false
end

local function getClassFromTool(tool)
    local rm = tool:FindFirstChild("RenderModel")
    if not rm then return nil end

    for _, model in ipairs(rm:GetChildren()) do
        local me = model:FindFirstChild("ModelExtents")
        local stats = me and me:FindFirstChild("StatsGui")
        local frame = stats and stats:FindFirstChild("Frame")
        local class = frame and frame:FindFirstChild("Class")

        if class and class:IsA("TextLabel") then
            return class.Text
        end
    end
    return nil
end

-- ================== SCAN ==================
local function scanTool(tool)
    if scanning then return end
    if not tool:IsA("Tool") then return end
    if Checked[tool] then return end
    Checked[tool] = true

    if shouldSkip(tool) then return end

    scanning = true
    local char = getCharacter()

    tool.Parent = char
    task.wait(delay_sell)

    local class = getClassFromTool(tool)
    if class then
        ClassData[tool] = class
        print("[SCAN]", tool.Name, class)
    end

    if tool.Parent == char then
        tool.Parent = lp.Backpack
    end

    scanning = false
end

local function scanAll()
    Checked = {}
    ClassData = {}

    local backpack = lp:WaitForChild("Backpack")
    for _, tool in ipairs(backpack:GetChildren()) do
        scanTool(tool)
        task.wait(delay_sell)
    end
end

-- ================== SELL ==================
local function processQueue()
    if selling then return end
    selling = true

    while #queue > 0 do
        local tool = table.remove(queue, 1)
        if tool and tool.Parent == lp.Backpack then
            tool.Parent = getCharacter()
            task.wait(delay_sell)
            SellRemote:InvokeServer()
            task.wait(delay_sell)
        end
    end

    selling = false
end

local function sellSelectedClasses()
    for tool, class in pairs(ClassData) do
        if selectedClasses[class] and tool.Parent == lp.Backpack then
            table.insert(queue, tool)
        end
    end
    processQueue()
end

local function scanThenSell()
    if scanning or selling then return end
    scanAll()
    task.wait(delay_sell * 2)
    sellSelectedClasses()
end

-- ================== WATCH NEW TOOLS ==================
local function connectBackpackWatcher()
    if backpackConn then
        backpackConn:Disconnect()
    end

    local backpack = lp:WaitForChild("Backpack")
    backpackConn = backpack.ChildAdded:Connect(function(tool)
        if not sellToggleOn then return end
        if not tool:IsA("Tool") then return end

        task.wait(0.15)
        scanTool(tool)

        local class = ClassData[tool]
        if class and selectedClasses[class] then
            table.insert(queue, tool)
            processQueue()
        end
    end)
end

-- ================== UI (FarmTab) ==================
WaveTab:Dropdown({
    Title = "Select Rarity Brainrot",
    Desc = "‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏£‡∏∞‡∏î‡∏±‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡∏´‡∏≤‡∏¢‡∏≤‡∏Å‡∏ó‡∏µ‡πà‡∏à‡∏∞‡∏Ç‡∏≤‡∏¢",
    Values = {
        "Common","Uncommon","Rare","Epic",
        "Legendary","Mythical","Cosmic",
        "Secret","Celestial","Divine"
    },
    Multi = true,
    AllowNone = true,
    Callback = function(selected)
        selectedClasses = {}
        for _, c in ipairs(selected) do
            selectedClasses[c] = true
        end

        -- ‡∏ñ‡πâ‡∏≤ Toggle ‡πÄ‡∏õ‡∏¥‡∏î‡∏≠‡∏¢‡∏π‡πà ‚Üí ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡πÅ‡∏•‡πâ‡∏ß‡∏Ç‡∏≤‡∏¢‡∏ó‡∏±‡∏ô‡∏ó‡∏µ
        if sellToggleOn then
            scanThenSell()
        end
    end
})

WaveTab:Toggle({
    Title = "Auto Sell Brainrot",
    Desc = "‡∏™‡πÅ‡∏Å‡∏ô‡πÅ‡∏•‡∏∞‡∏Ç‡∏≤‡∏¢‡∏ï‡∏≤‡∏°‡∏£‡∏∞‡∏î‡∏±‡∏ö‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å",
    Default = false,
    Callback = function(state)
        sellToggleOn = state

        if state then
            scanThenSell()
            connectBackpackWatcher()
        else
            if backpackConn then
                backpackConn:Disconnect()
                backpackConn = nil
            end
        end
    end
})

-- ================== RESPAWN ==================
lp.CharacterAdded:Connect(function()
    task.wait(0.6)

    Checked = {}
    ClassData = {}
    queue = {}
    scanning = false
    selling = false

    if sellToggleOn then
        scanThenSell()
        connectBackpackWatcher()
    end
end)





WaveTab:Toggle({
	Title = "Auto dodge Waveüåä",
	Desc = "‡∏´‡∏ô‡∏µ‡∏Ñ‡∏•‡∏∑‡πà‡∏ô‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥",
	Default = false,
	Callback = function(state)
		Enabled = state
	end
})

WaveTab:Button({
    Title = "Tween Gap",
    Desc = "‡∏Å‡∏î‡πÅ‡∏•‡πâ‡∏ß‡∏à‡∏∞‡∏°‡∏µ‡∏´‡∏ô‡πâ‡∏≤‡∏ï‡πà‡∏≤‡∏á‡∏™‡∏Ñ‡∏£‡∏¥‡∏õ‡πÄ‡∏™‡∏£‡∏¥‡∏°‡∏Ç‡∏∂‡πâ‡∏ô‡∏°‡∏≤",
    Callback = function()
        loadstring(game:HttpGet("https://raw.githubusercontent.com/reothebest13-art/ERROR-HUB/refs/heads/main/Gaptween"))()
    end
})

WaveTab:Toggle({
    Title = "There are 2-3 lives",
    Desc = "‡∏°‡∏µ2-3‡∏ä‡∏µ‡∏ß‡∏¥‡∏ï",
    Default = false,
    Callback = function(state)
        AntiWaveEnabled = state
        ClearConnections()

        if state then
            if lp.Character then
                AntiWaveInfinite(lp.Character)
            end

            table.insert(Connections,
                lp.CharacterAdded:Connect(function(char)
                    task.wait(0.5)
                    if AntiWaveEnabled then
                        AntiWaveInfinite(char)
                    end
                end)
            )
        end
    end
})


local ESPTab = Window:Tab({Title = "ESP", Icon = "eye"})


ESPTab:Section({
    Title = "‡∏°‡∏±‡∏ô‡∏ö‡∏±‡∏Ñ‡∏≠‡∏¢‡∏π‡πà‡πÄ‡∏î‡∏∞‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÉ‡∏´‡πâ‡∏ó‡∏µ‡∏´‡∏•‡∏±‡∏á"
})



local CombatTab = Window:Tab({Title = "Combat", Icon = "swords"})



CombatTab:Toggle({
    Title = "Hit Long",
    Desc = "‡∏ï‡∏µ‡πÑ‡∏Å‡∏•",
    Value = false,
    Callback = function(state)
        HitLongEnabled = state
        for _, tool in ipairs(bp:GetChildren()) do
            applyHitbox(tool)
        end
    end
})

CombatTab:Toggle({
    Title = "Show hit range",
    Desc = "‡πÇ‡∏ä‡∏ß‡πå‡∏£‡∏∞‡∏¢‡∏∞‡∏Å‡∏≤‡∏£‡∏ï‡∏µ",
    Value = false,
    Callback = function(state)
        ShowRangeEnabled = state
        for _, tool in ipairs(bp:GetChildren()) do
            applyVisual(tool)
        end
    end
})

CombatTab:Slider({
    Title = "hit range Value",
    Desc = "‡∏õ‡∏£‡∏±‡∏ö‡∏£‡∏∞‡∏¢‡∏∞‡∏Å‡∏≤‡∏£‡∏ï‡∏µ",
    Value = { Min = 10, Max = 200, Default = 50 },
    Step = 1,
    Callback = function(value)
        HitRangeValue = value

        for _, tool in ipairs(bp:GetChildren()) do
            if HitLongEnabled then
                applyHitbox(tool)
            end

            if ShowRangeEnabled then
                local box = tool:FindFirstChild("BoxVisual")
                if box then
                    box.Size = Vector3.new(value, value, value)
                end
            end
        end
    end
})



local AutoClickConnection = nil

CombatTab:Toggle({
    Title = "Auto Hit (Click screen)",
    Desc = "‡∏≠‡∏≠‡πÇ‡∏ï‡πâ‡∏ï‡∏µ (‡πÅ‡∏ö‡∏ö‡∏Ñ‡∏•‡∏¥‡∏Å‡∏´‡∏ô‡πâ‡∏≤‡∏à‡∏≠)",
    Default = false,
    Callback = function(state)
        if state then
            AutoClickConnection = RunService.RenderStepped:Connect(function()
                pcall(function()
                    VirtualUser:CaptureController()
                    VirtualUser:Button1Down(Vector2.new(1280, 672))
                    VirtualUser:Button1Up(Vector2.new(1280, 672))
                end)
            end)
        else
            if AutoClickConnection then
                AutoClickConnection:Disconnect()
                AutoClickConnection = nil
            end
        end
    end
})
